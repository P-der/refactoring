### 封装


#### 封装记录

- 动机：能直观的组织起存在关联的数据，可以将数据作为有意义的单元传递
- 做法：
  - 对持有记录的变量使用`封装变量`，将其封装到一个函数中
  - 创建一个类，将记录包装起来，并将记录变量的值替换为该类的一个实例。然后在类上定义一个访问函数，用于返回原始的记录。修改封装变量的函数，令其使用这个访问函数
  - 测试
  - 新建一个函数，让它返回该类的对象，而非那条原始的记录
  - 对于该记录的每个使用点，将原先返回记录的函数调用替换为那个返回实例对象的函数调用。使用对象上的访问函数来获取数据的字段，如果该字段的访问函数还不存在，那就创建一个。每次更改之后运行测试
  - 移除类对原始记录的访问函数，那个容易搜索的返回原始数据的函数也要一并删除
  - 测试
  - 如果记录中的字段本身也是复杂结构，考虑对其再次应用`封装记录`或`封装集合`手法


#### 封装集合

- 动机：封装程序中的所有可变变量，容易清楚数据被修改的地方和修改方式，这样当需要改变数据结构时会非常方便
- 做法：
  - 如果集合的引用尚未封装，先用`封装变量`封装
  - 在类上添加用于操作集合的函数如：添加元素、移除元素
  - 执行静态检查
  - 查找集合的引用点，如果有修改集合的地方，修改为类上的修改函数
  - 修改集合的取值函数，使其返回一份只读的数据，可以使用只读代理或者数据副本
  - 测试


#### 以对象取代基本类型

- 动机：一旦发现对某个数据的操作不仅仅局限于打印时
- 做法：
  - 如果变量尚未被封装起来，先使用`封装变量`封装它
  - 为这个数据值创建一个简单的类。类的构造函数应该保存这个数据值，并为它提供一个取值函数
  - 执行静态检查
  - 修改第一步得到的设值函数，令其创建一个新类的对象并将其存入字段，如果有必要的话，同时修改字段的类型声明
  - 修改取值函数，令其调用新类的取值函数，并返回结果
  - 测试
  - 考虑对第一步得到的访问函数使用`函数改名`，以便更好的反映其功能
  - 考虑应用`将引用对象改为值对象`或`将值对象改变为引用对象`，明确指出新对象的角色是值对象还是引用对象


#### 以查询取代临时变量

- 动机：适用于被计算一次后不再被修改的变量
- 做法：
  - 检查变量在使用前是否已经完全计算完毕，检查计算它的那段代码是否每次都能得到一样的值
  - 如果变量目前不是只读的，但是可以改造成只读变量，那就先改造它
  - 测试
  - 将为变量赋值的代码提炼成函数
  - 测试
  - 应用`内联变量`移除临时变量


#### 提炼类

- 动机：如果类变得过于庞大且不利于理解的时候需要把类拆解
- 做法：
  - 决定如何分解类所负的责任
  - 创建一个新的类，用以表现从旧类中分离出来的责任
  - 构造旧类时创建一个新类的实例，建立从旧类中访问新类的连接关系
  - 对于你想搬移的每一个字段，运用`搬移字段`搬移之。每次更改之后运行测试
  - 使用`搬移函数`将必要函数搬移到新类。先搬移较低层函数(也就是被其他函数调用多于调用其他函数者)。每次更改之后运行测试
  - 检查两个类的接口，去掉不再需要的函数，必要时为函数重新去一个适合新环境的名字
  - 决定是否公开新的类。如果确实需要，考虑对新类应用`将引用对象改为值对象`使其成为一个值对象


#### 内联类

- 动机：如果一个类不再承担足够的责任时，或者需要重新安排两个类的职责时，先进行内联，然后再重新分配
- 做法：
  - 对于待定内联类(源类)中所有public函数，在目标类上创建一个对应的函数，新创建的所有函数应该直接委托至源类
  - 修改源类public方法的所有引用点，令它们调用目标类对应的委托方法。每次更改之后运行测试
  - 将源类中的函数与数据全部搬移至目标类，每次修改后进行测试，直到源类变成空壳为止
  - 删除源类


#### 隐藏委托关系

- 动机：隐藏委托关系，去除调用依赖，减少变更影响的范围
- 做法：
  - 对于每个委托关系中的函数，在服务对象端建立一个简单的委托函数
  - 调整客户端，令它只调用服务对象提供的函数。每次调整后运行测试
  - 如果将来不再有任何客户端需要取用Delegate(受托类)，便可以移除服务对象中的相关访问函数
  - 测试


#### 移除中间人 

- 动机：当中间的委托过多的情况，与`隐藏委托关系`相反
- 做法：
  - 为受托对象创建一个取值函数
  - 对于每个委托函数，让其客户端转为连续的访问函数调用。每次替换后运行测试