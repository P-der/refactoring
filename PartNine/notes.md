### 重新组织数据



#### 拆分变量

- 动机：除了`循环变量`和`结果收集变量`外，一个变量不应该被重复赋值，因为代表变量承担的事情发生了变换，应该一个变量对应一个责任，如果变量承担了多个责任，就需要拆分
- 做法：
  - 在待分解变量的声明及其第一次被赋值处，修改其名称
  - 如果可能的话，新变量声明为不可修改
  - 以该变量的第二次赋值动作为界，修改此前对该变量的所有引用，让它们引用新变量
  - 测试
  - 重复上述过程。每次都在声明处对变量改名，并修改下次赋值之前的引用，直至到达最后一处赋值


#### 字段改名

- 动机：如果有更好的名字
- 做法：
  - 如果记录的作用域较小，可以直接修改所有改字段的代码，然后测试，后面的步骤就不需要了
  - 如果记录还未封装，请先使用封装记录
  - 在对象内部对私有字段改名，对应调整内部访问该字段的函数
  - 测试
  - 如果构造函数的参数用了旧的字段名，运用`改变函数声明`，将其改名
  - 运用`函数改名`给访问函数改名


#### 以查询取代派生变量

- 动机：有些可以很容易计算的变量，有时是可以去除的，使保存的数据，尽量使不可变的；如果数据是不可变的，可以忽略这个重构
- 做法：
  - 识别出所有对变量做更新的地方。如果有必要，用`拆分变量`分割各个更新点
  - 新建一个函数，用于计算该变量的值
  - 用`引入断言`断言该变量和计算函数始终给出同样的值(如果有必要，可以用`封装变量`把断言封装起来)
  - 测试
  - 修改读取该变量的代码，令其调用新创建的函数
  - 测试
  - 用`移除死代码`去掉变量的声明和赋值


#### 将引用对象改为值对象

- 动机：根据对值对象和引用对象的区别，针对需要视为值对象的引用对象进行替换
- 做法：
  - 检查重构目标是否为不可变对象，或者是否可修改为不可变对象
  - 用`移除设值函数`逐一去掉所有设值函数
  - 提供一个基于值的相等性判断函数，在其中使用值对象的字段


#### 将值对象改为引用对象

- 动机：如果数据需要共享的情况下，可以把值对象改为引用对象
- 做法：
  - 为相关对象创建一个仓库(如果还没有仓库的话)
  - 确保构造函数有办法找到关联对象的正确实例
  - 修改宿主对象的构造函数，令其从仓库中获取关联对象。每次修改后执行测试