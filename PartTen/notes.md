### 简化条件逻辑



#### 分解条件表达式
> 是`提炼函数`的一个应用场景
- 动机：为了保证在复杂条件逻辑函数中，提高代码的可读性，分解为多个函数，能更好的突出条件逻辑，清楚的表明每个分支的作用
- 做法：
  - 对条件判断和每个条件分支分别运用`提炼函数`手法


#### 合并条件表达式

- 动机：如果发现检测条件不同，但是行为相同，可以对其进行合并，如果确实是独立的情况，可以放弃本次重构
- 做法：
  - 确定这些条件表达式都没有副作用
  - 使用适当的逻辑运算符，将两个相关条件表达式合并为一个
  - 测试
  - 重复前面的合并过程，直到所有相关的条件表达式都合并到一起
  - 可以考虑对合并后的条件表达式实施`提炼函数`


#### 以卫语句取代嵌套条件表达式

- 动机：如果条件表达式中有某个条件极其罕见，就应该单独检查条件，并在该条件为真时立刻返回
- 做法：
  - 选中最外层需要被替换的条件逻辑，将其替换为卫语句
  - 测试
  - 如果有需要，重复上述步骤
  - 如果所有卫语句都引发相同的结果，可以使用`合并条件表达式`合并之


#### 以多态取代条件表达式

- 动机：如果复杂的条件逻辑情况满足可以根据不同场景进行拆分(或者叫高级用例)的情况，可以进行拆分
- 做法：
  - 如果现在的类尚不具备多态行为，就用工厂函数创建之，令工厂函数返回恰当的对象实例
  - 在调用方代码中使用工厂函数获得对象实例
  - 将带有条件逻辑的函数移到超类中
  - 任选一个子类，在其中创建一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新函数中，并对它进行适当调整
  - 重复上述过程，处理其他条件分支
  - 在超类函数中保留默认情况的逻辑。或者，如果超类应该是抽象的，就把该函数声明为`abstract`，或在其中直接抛出异常，表明计算责任都在子类中


#### 引入特例

- 动机：如果需要检查某个特定的值，并且处理也相同，就可以引入特例模式
- 做法：
  - 给重构目标添加检查特例的属性，令其返回`false`
  - 创建一个特例对象，其中只有检查特例的属性，返回`true`
  - 对“与特例值做比对”的代码运用`提炼函数`，确保所有客户端都使用这个新函数，而不再直接做特例值的比对
  - 将新的特例对象引入代码，可以从函数调用中返回，也可以在变换函数中生成
  - 修改特例比对函数的主体，在其中直接使用检查特例的属性
  - 测试
  - 使用`函数组合成类`或`函数组合成变换`，把通用的特例处理逻辑都搬移到新建的特例对象中
  - 对特例比对函数使用`内联函数`，将其内联到仍然需要的地方