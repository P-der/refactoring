### 处理继承关系



#### 函数上移

- 动机：避免重复代码
- 做法：
  - 检查待提升函数，确定它们是完全一致的
  - 检查函数体内引用的所有函数调用和字段都能从超类中调用到
  - 如果待提升函数的签名不同，使用`改变函数声明`将那些签名都修改为你想要在超类中使用的签名
  - 在超类中新建一个函数，将某一个待提升函数的代码复制到其中
  - 执行静态检查
  - 移除一个待提升的子类函数
  - 测试
  - 逐一移除待提升的子类函数，直到只剩下超类中的函数为止


#### 字段上移

- 动机：如果子类中某些字段使用的方式相似，就可以提升到超类中去
- 做法：
  - 针对待提升之字段，检查它们的所有使用点，确认它们以同样的方式被使用
  - 如果这些字段的名称不同，先使用`变量改名`为它们取个相同的名字
  - 在超类中新建一个字段
  - 移除子类中的字段
  - 测试


#### 构造函数本体上移

- 动机：针对构造函数中共用的部分提升到超类中
- 做法：
  - 如果超类还不存在构造函数，首先为其定义一个。确保让子类调用超类的构造函数
  - 使用`移动语句`将子类中构造函数中的公共语句移动到超类的构造函数调用语句之后
  - 逐一移除子类间的公共代码，将其提升至超类构造函数中。对于公共代码中引用的变量，将其作为参数传递给超类的构造函数
  - 测试
  - 如果存在无法简单提升至超类的公共代码，先应用`提炼函数`，再利用`函数上移`提升之


#### 函数下移

- 动机：如果超类中的某个函数只与一个或者少数几个子类有关，则最好移动到真正使用的子类中
- 做法：
  - 将超类中的函数本体复制到每一个需要此函数的子类中
  - 删除超类中的函数
  - 测试
  - 将该函数从所有不需要它的那些子类中删除
  - 测试


#### 字段下移

- 动机：如果某个字段只被一个子类或者一小部分子类用到，就将其搬移到需要该字段的子类中
- 做法：
  - 在所有需要该字段的子类中声明该字段
  - 将该字段从超类中移除
  - 测试
  - 将该字段从所有不需要它的那些子类中删掉
  - 测试


#### 以子类取代类型码

- 动机：在使用多态继承能解决问题，并且子类数量是固定的情况下，可以使用该重构方式
- 做法：
  - 自封装类型码字段
  - 任选一个类型码取值，为其创建一个子类。覆写类型码类的取值函数，令其返回该类型码的字面量值
  - 创建一个选择器逻辑，把类型码参数映射到新的子类
  - 测试
  - 针对每个类型码取值，重复上述“创建子类、添加选择器逻辑”的过程。每次修改后执行测试
  - 去除类型码字段
  - 测试
  - 使用`函数下移`和`以多态取代条件表达式`处理原本访问了类型码的函数。全部处理完成后，就可以移除类型码的访问函数


#### 移除子类

- 动机：如果子类的用处太少，可以选择移除子类
- 做法：
  - 使用`以工厂函数取代构造函数`，把子类的构造函数包装到超类的工厂函数中
  - 如果有任何代码检查子类的类型，先用`提炼函数`把类型检查逻辑包装起来，然后用`搬移函数`将其搬到超类。每次修改后执行测试
  - 新建一个字段，用于代表子类的类型
  - 将原本针对子类的类型做判断的函数改为使用新建的类型字段
  - 删除子类
  - 测试


#### 提炼超类

- 动机：如果发现两个类在做相似的事情，可以利用继承机制把它们相似之处提炼到超类
- 做法：
  - 为原本的类新建一个空白的超类
  - 测试
  - 使用`构造函数本体上移`、`函数上移`和`字段上移`手法，逐一将子类的共同元素上移到超类
  - 检查留在子类中的函数，看它们是否还有共同的成分。如果有，可以先用`提炼函数`将其提炼出来，再用`函数上移`搬移到超类
  - 检查所有使用原本的类的客户端代码，考虑将其调整为使用超类的接口